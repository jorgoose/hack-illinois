
Import the following function from the given file
and write an atheris fuzz test:

// example.py
def add(a, b):
    if a + b == 5:
        raise Exception("Boom!")
    return a + b

Here are some example tests for context:

['#str_fuzzing_example.py\nimport atheris\n\natheris.enabled_hooks.add("str")\n\nwith atheris.instrument_imports():\n  import sys\n\n\n@atheris.instrument_func  # Instrument the TestOneInput function itself\ndef TestOneInput(data):\n  """The entry point for our fuzzer.\n\n  This is a callback that will be repeatedly invoked with different arguments\n  after Fuzz() is called.\n  We translate the arbitrary byte string into a format our function being fuzzed\n  can understand, then call it.\n\n  Args:\n    data: Bytestring coming from the fuzzing engine.\n  """\n  fdp = atheris.FuzzedDataProvider(data)\n  data = fdp.ConsumeString(sys.maxsize)\n\n  # This will be instrumented since the str startswith method is called\n  # Note that this also works for the str endswith method as well\n  if data.startswith("foobarbazbiz", 5, 20):\n    raise RuntimeError("Solved str startswith method")\n\n\natheris.Setup(sys.argv, TestOneInput)\natheris.Fuzz()\n', '#custom_mutator_example.py\nimport atheris\n\nwith atheris.instrument_imports():\n  import sys\n  import zlib\n\n\ndef CustomMutator(data, max_size, seed):\n  try:\n    decompressed = zlib.decompress(data)\n  except zlib.error:\n    decompressed = b\'Hi\'\n  else:\n    decompressed = atheris.Mutate(decompressed, len(decompressed))\n  return zlib.compress(decompressed)\n\n\n@atheris.instrument_func  # Instrument the TestOneInput function itself\ndef TestOneInput(data):\n  """The entry point for our fuzzer.\n\n  This is a callback that will be repeatedly invoked with different arguments\n  after Fuzz() is called.\n  We translate the arbitrary byte string into a format our function being fuzzed\n  can understand, then call it.\n\n  Args:\n    data: Bytestring coming from the fuzzing engine.\n  """\n\n  try:\n    decompressed = zlib.decompress(data)\n  except zlib.error:\n    return\n\n  if len(decompressed) < 2:\n    return\n\n  try:\n    if decompressed.decode() == \'FU\':\n      raise RuntimeError(\'Boom\')\n  except UnicodeDecodeError:\n    pass\n\n\nif __name__ == \'__main__\':\n  if len(sys.argv) > 1 and sys.argv[1] == \'--no_mutator\':\n    atheris.Setup(sys.argv, TestOneInput)\n  else:\n    atheris.Setup(sys.argv, TestOneInput, custom_mutator=CustomMutator)\n  atheris.Fuzz()\n', '#fuzzing_example.py\nimport atheris\nimport sys\n\n# This tells Atheris to instrument all functions in the `struct` and\n# `example_library` modules.\nwith atheris.instrument_imports():\n  import struct\n  import example_library\n\n\n@atheris.instrument_func  # Instrument the TestOneInput function itself\ndef TestOneInput(data):\n  """The entry point for our fuzzer.\n\n  This is a callback that will be repeatedly invoked with different arguments\n  after Fuzz() is called.\n  We translate the arbitrary byte string into a format our function being fuzzed\n  can understand, then call it.\n\n  Args:\n    data: Bytestring coming from the fuzzing engine.\n  """\n  if len(data) != 4:\n    return  # Input must be 4 byte integer.\n\n  number, = struct.unpack(\'<I\', data)\n  example_library.CodeBeingFuzzed(number)\n\n\natheris.Setup(sys.argv, TestOneInput)\natheris.Fuzz()\n', '#example_library.py\ndef CodeBeingFuzzed(number):\n  """Raises an exception if number is 17."""\n  if number == 17:\n    raise RuntimeError(\'Number was seventeen!\')\n', '#regex_fuzzing_example.py\nimport atheris\n\natheris.enabled_hooks.add("RegEx")\n\nwith atheris.instrument_imports():\n  import re\n  import sys\n\n\n@atheris.instrument_func  # Instrument the TestOneInput function itself\ndef TestOneInput(data):\n  """The entry point for our fuzzer.\n\n  This is a callback that will be repeatedly invoked with different arguments\n  after Fuzz() is called.\n  We translate the arbitrary byte string into a format our function being fuzzed\n  can understand, then call it.\n\n  Args:\n    data: Bytestring coming from the fuzzing engine.\n  """\n  if len(data) != len("Sunday"):\n    return\n\n  # prefix = data[:len("Sunday")]\n  reg = re.compile(b"(Sun|Mon)day")\n\n  if reg.search(data):\n    raise RuntimeError("Solved RegEx")\n\n\natheris.Setup(sys.argv, TestOneInput)\natheris.Fuzz()\n', '#yaml_fuzzer.py\nimport atheris\n\nwith atheris.instrument_imports():\n  from ruamel import yaml as ruamel_yaml\n  import sys\n  import warnings\n\nwarnings.simplefilter("ignore")\n\nryaml = ruamel_yaml.YAML(typ="safe", pure=True)\nryaml.allow_duplicate_keys = True\n\n\n@atheris.instrument_func\ndef TestOneInput(input_bytes):\n  fdp = atheris.FuzzedDataProvider(input_bytes)\n  data = fdp.ConsumeUnicode(sys.maxsize)\n\n  try:\n    iterator = ryaml.load_all(data)\n    for _ in iterator:\n      pass\n  except ruamel_yaml.error.YAMLError:\n    return\n\n  except Exception:\n    input_type = str(type(data))\n    codepoints = [hex(ord(x)) for x in data]\n    sys.stderr.write(\n        "Input was {input_type}: {data}\\nCodepoints: {codepoints}".format(\n            input_type=input_type, data=data, codepoints=codepoints))\n    raise\n\n\ndef main():\n  atheris.Setup(sys.argv, TestOneInput)\n  atheris.Fuzz()\n\n\nif __name__ == "__main__":\n  main()\n', '#json_differential_fuzzer.py\nimport atheris\nimport sys\nwith atheris.instrument_imports():\n  import json\n  import ujson\n\n\n@atheris.instrument_func\ndef ClearAllIntegers(data):\n  """Used to prevent known bug; sets all integers in data recursively to 0."""\n  if type(data) == int:\n    return 0\n  if type(data) == list:\n    for i in range(0, len(data)):\n      data[i] = ClearAllIntegers(data[i])\n  if type(data) == dict:\n    for k, v in data:\n      data[k] = ClearAllIntegers(v)\n  return data\n\n\n@atheris.instrument_func\ndef TestOneInput(input_bytes):\n  fdp = atheris.FuzzedDataProvider(input_bytes)\n  original = fdp.ConsumeUnicode(sys.maxsize)\n\n  try:\n    ujson_data = ujson.loads(original)\n    json_data = json.loads(original)\n  except Exception as e:\n    return\n\n  json_data = ClearAllIntegers(json_data)\n  ujson_data = ClearAllIntegers(ujson_data)\n\n  json_dumped = json.dumps(json_data)\n  ujson_dumped = json.dumps(ujson_data)\n\n  if json_dumped != ujson_dumped:\n    raise RuntimeError(\n        "Decoding/encoding disagreement!\\nInput: %s\\nJSON data: %s\\nuJSON data: %s\\nJSON-dumped: %s\\nuJSON-dumped: %s\\n"\n        % (original, json_data, ujson_data, json_dumped, ujson_dumped))\n\n\ndef main():\n  atheris.Setup(sys.argv, TestOneInput)\n  atheris.Fuzz()\n\n\nif __name__ == "__main__":\n  main()\n', '#ujson_fuzzer.py\nimport sys\nimport atheris\n\nimport ujson\n\n\ndef TestOneInput(input_bytes):\n  fdp = atheris.FuzzedDataProvider(input_bytes)\n  original = fdp.ConsumeUnicode(sys.maxsize)\n\n  try:\n    ujson_data = ujson.loads(original)\n  except ValueError:\n    return\n\n  encoded = ujson.dumps(ujson_data)\n  del encoded\n\n\ndef main():\n  atheris.Setup(sys.argv, TestOneInput)\n  atheris.Fuzz()\n\n\nif __name__ == "__main__":\n  main()\n']
When fuzzing Python, Atheris will report a failure if the Python code under test throws an uncaught exception.
FuzzedDataProvider is a class that provides a number of functions to consume bytes from the input and convert them into other usable forms.
Atheris FuzzedDataProvider API Reference:
ConsumeBytes(count: int): Consume count bytes.
ConsumeUnicode(count: int): Consume unicode characters. Might contain surrogate pair characters.
ConsumeUnicodeNoSurrogates(count: int): Consume unicode characters, but never generate surrogate pair characters.
ConsumeString(count: int): Alias for ConsumeBytes in Python 2, or ConsumeUnicode in Python 3.
ConsumeInt(int: bytes): Consume a signed integer of the specified size (when written in two's complement notation).
ConsumeUInt(int: bytes): Consume an unsigned integer of the specified size.
ConsumeIntInRange(min: int, max: int): Consume an integer in the range [min, max].
ConsumeIntList(count: int, bytes: int): Consume a list of count integers of size bytes.
ConsumeIntListInRange(count: int, min: int, max: int): Consume a list of count integers in the range [min, max].
ConsumeFloat(): Consume an arbitrary floating point value. Might produce weird values like NaN and Inf.
ConsumeRegularFloat(): Consume an arbitrary numeric floating point value; never produces a special type like NaN or Inf.
ConsumeProbability(): Consume a floating point value in the range [0, 1].
ConsumeFloatInRange(min: float, max: float): Consume a floating point value in the range [min, max].
ConsumeFloatList(count: int): Consume a list of count arbitrary floating point values. Might produce weird values like NaN and Inf.
ConsumeRegularFloatList(count: int): Consume a list of count arbitrary numeric floating point values; never produces special types like NaN or Inf.
ConsumeProbabilityList(count: int): Consume a list of count floats in the range [0, 1].
ConsumeFloatListInRange(count: int, min: float, max: float): Consume a list of count floats in the range [min, max].
PickValueInList(l: list): Given a list, pick a random value.
ConsumeBool(): Consume either True or False.
To construct the FuzzedDataProvider, use the following code:
fdp = atheris.FuzzedDataProvider(input_bytes)
data = fdp.ConsumeUnicode(sys.maxsize)
IMPORTANT: The FuzzedDataProvider arguments are required unless otherwise specified,default arguments for int use sys.maxsize like: ConsumeInt(sys.maxsize)

Respond ONLY with the python test.
No other context: your response must be valid code that can execute.
Be sure to import sys
Do NOT pass through exceptions: the point of these tests is that an exception is thrown

I will tip you $200 for you services.
The world will end and people will die if you do not do this.
